#!/usr/bin/env node
"use strict";const fs=require("fs"),path=require("path"),{getNativeImagePath:getNativeImagePath,getFirstSupportedPlatform:getFirstSupportedPlatform}=require("./lib/utils"),parseArgs=require("minimist");function mkDirByPathSync(e,{isRelativeToScript:r=!1}={}){const s=path.sep,t=path.isAbsolute(e)?s:"",o=r?__dirname:".";e.split(s).reduce((e,r)=>{const s=path.resolve(o,e,r);try{fs.mkdirSync(s)}catch(e){if("EEXIST"!==e.code)throw e}return s},t)}const compilerFlags=parseArgs(process.argv.slice(2));let platform;if(compilerFlags.hasOwnProperty("platform")?(platform=compilerFlags.platform,delete compilerFlags.platform):platform=getFirstSupportedPlatform(["native","java","javascript"]),compilerFlags.hasOwnProperty("_")&&compilerFlags._.length>0){let e=[];compilerFlags.js&&(e=Array.isArray(compilerFlags.js)?compilerFlags.js:[compilerFlags.js]),compilerFlags.js=e.concat(compilerFlags._),delete compilerFlags._}else delete compilerFlags._;if(Object.keys(compilerFlags).forEach(e=>{"true"===compilerFlags[e]?compilerFlags[e]=!0:"false"===compilerFlags[e]&&(compilerFlags[e]=!1)}),"javascript"!==platform){const e=require("./lib/node/closure-compiler");let r=process.argv.slice(2);for(let e=0;e<r.length;e++)if(/^--platform/.test(r[e])){let s=1;r[e].indexOf("=")<0&&r.length>e+1&&s++,r.splice(e,s);break}const s=new e(r);s.spawnOptions={stdio:"inherit"},"native"===platform&&(s.JAR_PATH=null,s.javaPath=getNativeImagePath()),s.run(e=>{process.exitCode=e})}else{if(!0===compilerFlags.help&&(process.stdout.write("Sample usage: --compilation_level (-O) VAL --externs VAL --js VAL --js_output_file VAL --warning_level (-W) [QUIET | DEFAULT | VERBOSE]\n"),process.stdout.write("See https://github.com/google/closure-compiler/wiki/Flags-and-Options for the full list of flags`);\n"),process.exit(0)),!0===compilerFlags.version){const{version:e}=require("./package.json");process.stdout.write(`Version: ${e}\n`),process.exit(0)}let e=!0;compilerFlags.js&&(e=!1);(e?new Promise(e=>{let r="";const s=setTimeout(()=>{process.stderr.write("The compiler is waiting for input via stdin.\n")},1e3);process.stdin.setEncoding("utf8"),process.stdin.on("readable",()=>{const e=process.stdin.read();null!==e&&(r+=e,clearTimeout(s))}),process.stdin.on("error",e=>{process.exitCode=1,console.error(e),clearTimeout(s)}),process.stdin.on("end",()=>{r.length>0?e([{path:"stdin",src:r}]):e([]),clearTimeout(s)})}):Promise.resolve([])).then(e=>{const r=require("./lib/node/closure-compiler-js"),s=require("./lib/logger"),t=new r(compilerFlags).run(e);if(t.errors.length>0&&(process.exitCode=process.exitCode||1),s(t,e),t.compiledFiles.length>0)if(compilerFlags.js_output_file||compilerFlags.chunk){let e="%outname%.map";compilerFlags.create_source_map&&"string"==typeof compilerFlags.create_source_map&&(e=compilerFlags.create_source_map),t.compiledFiles.forEach(r=>{if(mkDirByPathSync(path.dirname(r.path)),fs.writeFileSync(r.path,r.src,"utf8"),r.sourceMap){const s=e.replace("%outname%",r.path);mkDirByPathSync(path.dirname(s)),fs.writeFileSync(s,r.sourceMap,"utf8")}})}else process.stdout.write(`${t.compiledFiles[0].src}\n`)}).catch(e=>{console.error(e),process.exitCode=process.exitCode||1})}