goog.module("goog.streams.fullImpl");const NativeResolver=goog.require("goog.promise.NativeResolver"),fullTypes=goog.require("goog.streams.fullTypes"),liteImpl=goog.require("goog.streams.liteImpl"),{assert:assert,assertNumber:assertNumber}=goog.require("goog.asserts");let StartAlgorithm,CancelAlgorithm,PullAlgorithm;class ReadableStream extends liteImpl.ReadableStream{constructor(){super(),this[Symbol.asyncIterator]=this.getIterator,this.disturbed=!1}getReader(){return this.reader=new ReadableStreamDefaultReader(this)}cancel(e){return this.locked?Promise.reject(new TypeError("Cannot cancel a locked stream")):this.cancelInternal(e)}getIterator({preventCancel:e=!1}={}){return new ReadableStreamAsyncIterator(this.getReader(),e)}tee(){const e=this.getReader();let t,r,a,l,s=!1,i=!1,o=!1;const n=new NativeResolver,u=()=>(s||(s=!0,e.read().then(({value:e,done:t})=>{if(s=!1,t)return i||a.readableStreamController.close(),void(o||l.readableStreamController.close());i||a.readableStreamController.enqueue(e),o||l.readableStreamController.enqueue(e)}).catch(()=>{})),Promise.resolve()),h=()=>{};a=new ReadableStream;const d=new ReadableStreamDefaultController(a,e=>{if(i=!0,t=e,o){const e=this.cancelInternal([t,r]);n.resolve(e)}return n.promise},u,1,void 0);a.readableStreamController=d,d.start(h),l=new ReadableStream;const c=new ReadableStreamDefaultController(l,e=>{if(o=!0,r=e,i){const e=this.cancelInternal([t,r]);n.resolve(e)}return n.promise},u,1,void 0);return l.readableStreamController=c,c.start(h),e.closed.catch(e=>{d.error(e),c.error(e)}),[a,l]}cancelInternal(e){return this.disturbed=!0,this.state===liteImpl.ReadableStream.State.CLOSED?Promise.resolve():this.state===liteImpl.ReadableStream.State.ERRORED?Promise.reject(this.storedError):(this.close(),this.readableStreamController.cancelSteps(e).then(()=>{}))}}function newReadableStream(e={},t={}){const r=e;assert(!r.type,"'type' property not allowed on an underlying source for a liteImpl ReadableStream"),assert(!r.autoAllocateChunkSize,"'autoAllocateChunkSize' property not allowed on an underlying source for a liteImpl ReadableStream");const a=e.start?t=>e.start(t):()=>{},l=e.cancel?t=>{try{return Promise.resolve(e.cancel(t))}catch(e){return Promise.reject(e)}}:void 0,s=e.pull?t=>{try{return Promise.resolve(e.pull(t))}catch(e){return Promise.reject(e)}}:void 0,i=void 0===t.highWaterMark?1:t.highWaterMark,o=t.size?e=>t.size.call(void 0,e):void 0,n=new ReadableStream,u=new ReadableStreamDefaultController(n,l,s,i,o);return n.readableStreamController=u,u.start(a),n}class ReadableStreamDefaultReader extends liteImpl.ReadableStreamDefaultReader{cancel(e){return this.ownerReadableStream?this.ownerReadableStream.cancelInternal(e):Promise.reject(new TypeError("This readable stream reader has been released and cannot be used to cancel its previous owner stream"))}}class ReadableStreamAsyncIterator{constructor(e,t){this.asyncIteratorReader=e,this.preventCancel=t}next(){return this.asyncIteratorReader.ownerReadableStream?this.asyncIteratorReader.read().then(({value:e,done:t})=>(t&&this.asyncIteratorReader.release(),{value:e,done:t})):Promise.reject(new TypeError("There is no more data left in the ReadableStream"))}return(e){if(!this.asyncIteratorReader.ownerReadableStream)return Promise.reject(new TypeError("There is no more data left in the ReadableStream"));if(this.asyncIteratorReader.readRequests.length)return Promise.reject(new TypeError("There are pending read requests in the ReadableStream"));if(!this.preventCancel){const t=this.asyncIteratorReader.cancel(e);return this.asyncIteratorReader.release(),t.then(()=>({done:!0,value:e}))}return this.asyncIteratorReader.release(),Promise.resolve({done:!0,value:e})}}class ReadableStreamDefaultController extends liteImpl.ReadableStreamDefaultController{constructor(e,t,r,a,l){super(e),this.cancelAlgorithm_=t,this.pullAgain_=!1,this.pullAlgorithm_=r,this.pulling_=!1,this.queueTotalSize_=0,this.started_=!1,this.strategyHWM_=a,this.strategySizeAlgorithm_=l,this.queueWithSizes_=new QueueWithSizes(this.queue)}get desiredSize(){return this.getDesiredSize_()}started(){this.started_=!0,this.callPullIfNeeded()}callPullIfNeeded(){this.pullAlgorithm_&&this.shouldCallPull_()&&(this.pulling_?this.pullAgain_=!0:(this.pulling_=!0,this.pullAlgorithm_(this).then(()=>{this.pulling_=!1,this.pullAgain_&&(this.pullAgain_=!1,this.callPullIfNeeded())},e=>{this.error(e)})))}shouldCallPull_(){return!!this.canCloseOrEnqueue()&&(!!this.started_&&(!!(this.controlledReadableStream.locked&&this.controlledReadableStream.getNumReadRequests()>0)||assertNumber(this.getDesiredSize_())>0))}clearAlgorithms(){this.cancelAlgorithm_=void 0,this.pullAlgorithm_=void 0,this.strategySizeAlgorithm_=void 0}cancelSteps(e){this.queue.resetQueue();const t=this.cancelAlgorithm_?this.cancelAlgorithm_(e):Promise.resolve();return this.clearAlgorithms(),t}enqueueIntoQueue(e){let t;try{t=Number(this.strategySizeAlgorithm_?this.strategySizeAlgorithm_(e):1)}catch(e){throw this.error(e),e}if("number"!=typeof t||Number.isNaN(t)||t<0||t===1/0)throw new RangeError("The return value of a queuing strategy's size function must be a finite, non-NaN, non-negative number");this.queueTotalSize_+=t,this.queueWithSizes_.enqueueValueWithSize(e,t)}dequeueFromQueue(){const{value:e,size:t}=this.queueWithSizes_.dequeueValueWithSize();return this.queueTotalSize_-=t,this.queueTotalSize_<0&&(this.queueTotalSize_=0),e}resetQueue(){this.queueWithSizes_.resetQueue()}getDesiredSize_(){return this.controlledReadableStream.state===liteImpl.ReadableStream.State.ERRORED?null:this.controlledReadableStream.state===liteImpl.ReadableStream.State.CLOSED?0:this.strategyHWM_-this.queueTotalSize_}}class QueueWithSizes{constructor(e){this.queue_=e,this.sizes_=[]}enqueueValueWithSize(e,t){this.queue_.enqueueValue(e),this.sizes_.push(t)}dequeueValueWithSize(){return{value:this.queue_.dequeueValue(),size:this.sizes_.shift()}}resetQueue(){this.queue_.resetQueue(),this.sizes_=[]}}exports={ReadableStream:ReadableStream,ReadableStreamAsyncIterator:ReadableStreamAsyncIterator,ReadableStreamDefaultController:ReadableStreamDefaultController,ReadableStreamDefaultReader:ReadableStreamDefaultReader,newReadableStream:newReadableStream};