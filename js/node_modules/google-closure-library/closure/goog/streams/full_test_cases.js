goog.module("goog.streams.fullTestCases"),goog.setTestOnly();const recordFunction=goog.require("goog.testing.recordFunction"),{ReadableStream:ReadableStream,ReadableStreamDefaultController:ReadableStreamDefaultController,ReadableStreamStrategy:ReadableStreamStrategy,ReadableStreamUnderlyingSource:ReadableStreamUnderlyingSource}=goog.require("goog.streams.fullTypes"),{TestCases:LiteTestCases}=goog.require("goog.streams.liteTestCases"),chunkSizeTwo=()=>2;class TestCases extends LiteTestCases{constructor(e){super(e),this.newReadableStream}newReadableStreamWithController(e={},r={}){let t;const a=e.start;e=Object.assign({},e,{start:e=>(t=e,a&&a(e))});return{stream:this.newReadableStream(e,r),controller:t}}async testCancel(){const e=this.newReadableStream(),r=await e.cancel(new Error("error"));assertUndefined(r);const{done:t}=await e.getReader().read();assertTrue(t)}async testCancel_Closed(){const{stream:e,controller:r}=this.newReadableStreamWithController();r.close();const t=await e.cancel(new Error("error"));assertUndefined(t);const{done:a}=await e.getReader().read();assertTrue(a)}async testCancel_Errored(){const{stream:e,controller:r}=this.newReadableStreamWithController(),t=new Error("error");r.error(t);const a=await assertRejects(e.cancel(new Error("other-error")));assertEquals(t,a)}async testCancel_Locked(){const e=this.newReadableStream();e.getReader(),await assertRejects(e.cancel(new Error("error")))}async testCancel_Source(){const e=recordFunction(),r=this.newReadableStream({cancel:e}),t=new Error("error");await r.cancel(t),e.assertCallCount(1),assertEquals(t,e.getLastCall().getArguments()[0])}async testCancel_ThrowingSource(){const e=new Error("error"),r=recordFunction(()=>{throw e}),t=this.newReadableStream({cancel:r}),a=await assertRejects(t.cancel(new Error("other-error")));assertEquals(e,a)}async testCancel_RejectingSource(){const e=new Error("error"),r=recordFunction(()=>Promise.reject(e)),t=this.newReadableStream({cancel:r}),a=await assertRejects(t.cancel(new Error("other-error")));assertEquals(e,a)}async testReaderCancel(){const e=this.newReadableStream().getReader(),r=await e.cancel(new Error("error"));assertUndefined(r);const{done:t}=await e.read();assertTrue(t)}async testReaderCancel_Closed(){const{stream:e,controller:r}=this.newReadableStreamWithController(),t=e.getReader();r.close();const a=await t.cancel(new Error("error"));assertUndefined(a);const{done:s}=await t.read();assertTrue(s)}async testReaderCancel_Errored(){const{stream:e,controller:r}=this.newReadableStreamWithController(),t=new Error("error");r.error(t);const a=await assertRejects(e.getReader().cancel(new Error("other-error")));assertEquals(t,a)}async testReaderCancel_Source(){const e=recordFunction(),r=this.newReadableStream({cancel:e}),t=new Error("error");await r.getReader().cancel(t),e.assertCallCount(1),assertEquals(t,e.getLastCall().getArguments()[0])}async testReaderCancel_ThrowingSource(){const e=new Error("error"),r=recordFunction(()=>{throw e}),t=this.newReadableStream({cancel:r}),a=await assertRejects(t.getReader().cancel(new Error("other-error")));assertEquals(e,a)}async testReaderCancel_RejectingSource(){const e=new Error("error"),r=recordFunction(()=>Promise.reject(e)),t=this.newReadableStream({cancel:r}),a=await assertRejects(t.getReader().cancel(new Error("other-error")));assertEquals(e,a)}async testReaderCancel_ReleasedReader(){const e=this.newReadableStream().getReader();e.releaseLock(),await assertRejects(e.cancel(new Error("error")))}testDesiredSize_Default_Decreases(){const{controller:e}=this.newReadableStreamWithController();assertEquals(1,e.desiredSize),e.enqueue("foo"),assertEquals(0,e.desiredSize),e.enqueue("bar"),assertEquals(-1,e.desiredSize)}async testDesiredSize_Default_Increases(){const{stream:e,controller:r}=this.newReadableStreamWithController();r.enqueue("foo"),r.enqueue("bar"),r.enqueue("baz"),assertEquals(-2,r.desiredSize);const t=e.getReader();await t.read(),assertEquals(-1,r.desiredSize),await t.read(),assertEquals(0,r.desiredSize),await t.read(),assertEquals(1,r.desiredSize)}testDesiredSize_Default_Errored(){const{controller:e}=this.newReadableStreamWithController();e.error(new Error("error")),assertNull(e.desiredSize)}testDesiredSize_Default_Closed(){const{controller:e}=this.newReadableStreamWithController();e.close(),assertEquals(0,e.desiredSize)}testDesiredSize_CustomSize_Decreases(){const{controller:e}=this.newReadableStreamWithController(void 0,{size:chunkSizeTwo});assertEquals(1,e.desiredSize),e.enqueue("foo"),assertEquals(-1,e.desiredSize),e.enqueue("bar"),assertEquals(-3,e.desiredSize)}async testDesiredSize_CustomSize_Increases(){const{stream:e,controller:r}=this.newReadableStreamWithController(void 0,{size:chunkSizeTwo});r.enqueue("foo"),r.enqueue("bar"),r.enqueue("baz"),assertEquals(-5,r.desiredSize);const t=e.getReader();await t.read(),assertEquals(-3,r.desiredSize),await t.read(),assertEquals(-1,r.desiredSize),await t.read(),assertEquals(1,r.desiredSize)}testDesiredSize_CustomSize_Errored(){const{controller:e}=this.newReadableStreamWithController(void 0,{size:chunkSizeTwo});e.error(new Error("error")),assertNull(e.desiredSize)}testDesiredSize_CustomSize_Closed(){const{controller:e}=this.newReadableStreamWithController(void 0,{size:chunkSizeTwo});e.close(),assertEquals(0,e.desiredSize)}testDesiredSize_CustomHighWaterMark_Decreases(){const{controller:e}=this.newReadableStreamWithController(void 0,{highWaterMark:4});assertEquals(4,e.desiredSize),e.enqueue("foo"),assertEquals(3,e.desiredSize),e.enqueue("bar"),assertEquals(2,e.desiredSize)}async testDesiredSize_CustomHighWaterMark_Increases(){const{stream:e,controller:r}=this.newReadableStreamWithController(void 0,{highWaterMark:4});r.enqueue("foo"),r.enqueue("bar"),r.enqueue("baz"),assertEquals(1,r.desiredSize);const t=e.getReader();await t.read(),assertEquals(2,r.desiredSize),await t.read(),assertEquals(3,r.desiredSize),await t.read(),assertEquals(4,r.desiredSize)}testDesiredSize_CustomHighWaterMark_Errored(){const{controller:e}=this.newReadableStreamWithController(void 0,{highWaterMark:4});e.error(new Error("error")),assertNull(e.desiredSize)}testDesiredSize_CustomHighWaterMark_Closed(){const{controller:e}=this.newReadableStreamWithController(void 0,{highWaterMark:4});e.close(),assertEquals(0,e.desiredSize)}testSize_Chunks(){const e=recordFunction(()=>1),{controller:r}=this.newReadableStreamWithController(void 0,{size:e});r.enqueue("foo"),r.enqueue("bar"),r.enqueue("baz"),e.assertCallCount(3),assertObjectEquals([["foo"],["bar"],["baz"]],e.getCalls().map(e=>e.getArguments()))}testSize_Negative(){const{controller:e}=this.newReadableStreamWithController(void 0,{size:()=>-1});assertThrows(()=>{e.enqueue("foo")})}testSize_Infinity(){const{controller:e}=this.newReadableStreamWithController(void 0,{size:()=>1/0});assertThrows(()=>{e.enqueue("foo")})}testSize_NonNumber(){const{controller:e}=this.newReadableStreamWithController(void 0,{size:()=>"bar"});assertThrows(()=>{e.enqueue("foo")})}testSize_Throws(){const{controller:e}=this.newReadableStreamWithController(void 0,{size:()=>{throw new Error("error")}});assertThrows(()=>{e.enqueue("foo")})}async testPull(){const e=recordFunction();this.newReadableStreamWithController({pull:e}),await void 0,e.assertCallCount(1),await void 0,e.assertCallCount(1)}async testPull_StartEnqueue(){const e=recordFunction();this.newReadableStreamWithController({start(e){e.enqueue("foo")},pull:e}),await void 0,e.assertCallCount(0)}async testPull_AfterAsyncStart(){const e=recordFunction();let r;const t=new Promise(e=>{r=e}),a=recordFunction(()=>t);this.newReadableStreamWithController({start:a,pull:e}),await void 0,e.assertCallCount(0),r(),await t,e.assertCallCount(1)}async testPull_AfterAsyncStart_PreventsReadPulls(){const e=recordFunction();let r;const t=new Promise(e=>{r=e}),a=recordFunction(()=>t),{stream:s}=this.newReadableStreamWithController({start:a,pull:e});e.assertCallCount(0),s.getReader().read(),e.assertCallCount(0),r(),await t,e.assertCallCount(1)}async testPull_AfterRead(){const e=recordFunction(),{stream:r}=this.newReadableStreamWithController({pull:e});await e.waitForCalls(1),e.reset(),r.getReader().read(),e.assertCallCount(1)}async testPull_AfterReadOnEmptyStream(){const e=recordFunction(),{stream:r}=this.newReadableStreamWithController({pull:e});await e.waitForCalls(1),e.reset(),r.getReader().read(),e.assertCallCount(1)}async testPull_AfterTwoReadsOnEmptyStream(){const e=recordFunction(),{stream:r}=this.newReadableStreamWithController({pull:e});await e.waitForCalls(1),e.reset();const t=r.getReader();t.read(),e.assertCallCount(1),t.read(),e.assertCallCount(1),await void 0,e.assertCallCount(2)}async testPull_AfterManyReadsOnEmptyStream(){const e=recordFunction(),{stream:r}=this.newReadableStreamWithController({pull:e});await e.waitForCalls(1),e.reset();const t=r.getReader();t.read(),t.read(),t.read(),t.read(),t.read(),await 0,e.assertCallCount(2)}async testPull_Asynchronous(){let e;const r=new Promise(r=>{e=r}),t=recordFunction(()=>r),{stream:a}=this.newReadableStreamWithController({pull:t});await t.waitForCalls(1);const s=a.getReader();s.read(),s.read(),s.read(),t.assertCallCount(1),e(),await r,t.assertCallCount(2)}async testPull_Throws(){const e=recordFunction(()=>{throw new Error("error")}),{stream:r}=this.newReadableStreamWithController({pull:e}),t=r.getReader();await assertRejects(t.read())}async testPull_Rejects(){const e=recordFunction(()=>Promise.reject(new Error("error"))),{stream:r}=this.newReadableStreamWithController({pull:e}),t=r.getReader();await assertRejects(t.read())}async testTee(){const{stream:e,controller:r}=this.newReadableStreamWithController();r.enqueue("1"),r.enqueue("2"),r.enqueue("3"),r.close();const[t,a]=e.tee(),s=[],o=t.getReader();let n=await o.read();for(;!n.done;)s.push(n.value),n=await o.read();assertArrayEquals(["1","2","3"],s);const l=[],c=a.getReader();let i=await c.read();for(;!i.done;)l.push(i.value),i=await c.read();assertArrayEquals(["1","2","3"],l)}async testTee_Cancel(){const e=recordFunction(),{stream:r,controller:t}=this.newReadableStreamWithController({cancel:e}),[a,s]=r.tee(),o=a.cancel("reason1");e.assertCallCount(0),await 0,e.assertCallCount(0);const n=s.cancel("reason2");e.assertCallCount(1),assertArrayEquals(["reason1","reason2"],e.getLastCall().getArguments()[0]);const l=await o,c=await n;assertUndefined(l),assertUndefined(c)}async testTee_Cancel_ReverseOrder(){const e=recordFunction(),{stream:r,controller:t}=this.newReadableStreamWithController({cancel:e}),[a,s]=r.tee(),o=s.cancel("reason2");e.assertCallCount(0),await 0,e.assertCallCount(0);const n=a.cancel("reason1");e.assertCallCount(1),assertArrayEquals(["reason1","reason2"],e.getLastCall().getArguments()[0]);const l=await n,c=await o;assertUndefined(l),assertUndefined(c)}async testTee_Cancel_NoCancelOnSource(){const{stream:e,controller:r}=this.newReadableStreamWithController(),[t,a]=e.tee(),s=t.cancel("reason1"),o=a.cancel("reason2"),n=await s,l=await o;assertUndefined(n),assertUndefined(l)}async testTee_Cancel_Rejects(){const e=new Error("error"),r=recordFunction(()=>{throw e}),{stream:t,controller:a}=this.newReadableStreamWithController({cancel:r}),[s,o]=t.tee(),n=s.cancel("reason1"),l=o.cancel("reason2"),c=await assertRejects(n),i=await assertRejects(l);assertEquals(e,c),assertEquals(e,i)}async testTee_Locked(){const e=this.newReadableStream();e.getReader(),assertThrows(()=>{e.tee()})}}class TestCasesWithIterator extends TestCases{async testAsyncIterator(){const{stream:e,controller:r}=this.newReadableStreamWithController();r.enqueue("foo"),r.enqueue("bar"),r.close();const t=[];for await(const r of e)t.push(r);assertArrayEquals(["foo","bar"],t)}async testAsyncIterator_Closed(){const{stream:e,controller:r}=this.newReadableStreamWithController();r.close();const t=[];for await(const r of e)t.push(r);assertArrayEquals([],t)}async testAsyncIterator_Error(){const{stream:e,controller:r}=this.newReadableStreamWithController();r.error(new Error("error"));const t=e[Symbol.asyncIterator]();assertRejects(t.next())}async testAsyncIterator_Locked(){const e=this.newReadableStream();e.getReader(),assertThrows(()=>{e[Symbol.asyncIterator]()})}async testAsyncIterator_Partial(){const{stream:e,controller:r}=this.newReadableStreamWithController();r.enqueue("foo"),r.enqueue("bar"),r.close();const t=e.getReader();await t.read(),t.releaseLock();const a=[];for await(const r of e)a.push(r);assertArrayEquals(["bar"],a)}async testAsyncIterator_Released(){const{stream:e,controller:r}=this.newReadableStreamWithController();r.close();const t=e[Symbol.asyncIterator](),{done:a}=await t.next();assertTrue(a),assertRejects(t.next())}async testAsyncIterator_Return(){const e=recordFunction(),{stream:r,controller:t}=this.newReadableStreamWithController({cancel:e}),a=r[Symbol.asyncIterator](),s=new Error("error"),o=await a.return(s);e.assertCallCount(1),assertArrayEquals([s],e.getLastCall().getArguments()),assertEquals(s,o.value),assertTrue(o.done);const n=r.getReader(),l=await n.read();assertUndefined(l.value),assertTrue(l.done)}async testAsyncIterator_PreventCancel_Return(){const e=recordFunction(),{stream:r,controller:t}=this.newReadableStreamWithController({cancel:e}),a=r[Symbol.asyncIterator]({preventCancel:!0}),s=new Error("error"),o=await a.return(s);e.assertCallCount(0),assertEquals(s,o.value),assertTrue(o.done),await assertRejects(a.next())}testGetIterator(){const e=this.newReadableStream();assertEquals(e.getIterator,e[Symbol.asyncIterator])}}exports={TestCases:TestCases,TestCasesWithIterator:TestCasesWithIterator};