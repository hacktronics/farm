goog.module("goog.streams.liteImpl");const NativeResolver=goog.require("goog.promise.NativeResolver"),liteTypes=goog.require("goog.streams.liteTypes"),{assert:assert,assertFunction:assertFunction}=goog.require("goog.asserts");class ReadableStream{constructor(){this.state=ReadableStream.State.READABLE,this.reader=void 0,this.storedError=void 0,this.readableStreamController}get locked(){return void 0!==this.reader}getReader(){return this.reader=new ReadableStreamDefaultReader(this)}addReadRequest(){const e=new NativeResolver;return this.reader.readRequests.push(e),e.promise}close(){if(this.state=ReadableStream.State.CLOSED,this.reader){for(const e of this.reader.readRequests)e.resolve({value:void 0,done:!0});this.reader.readRequests=[],this.reader.closedResolver.resolve()}}error(e){if(this.state=ReadableStream.State.ERRORED,this.storedError=e,this.reader){for(const t of this.reader.readRequests)t.reject(e);this.reader.readRequests=[],this.reader.closedResolver.promise.catch(()=>{}),this.reader.closedResolver.reject(e)}}fulfillReadRequest(e,t){assert(this.reader).readRequests.shift().resolve({value:e,done:t})}getNumReadRequests(){return assert(this.reader).readRequests.length}hasDefaultReader(){return void 0!==this.reader}}function newReadableStream(e){assertFunction(e.start,"'start' property must be a function on an underlying source for a lite ReadableStream");const t=e;assert(!t.pull,"'pull' property not allowed on an underlying source for a lite ReadableStream"),assert(!t.cancel,"'cancel' property not allowed on an underlying source for a lite ReadableStream"),assert(!t.type,"'type' property not allowed on an underlying source for a lite ReadableStream"),assert(!t.autoAllocateChunkSize,"'autoAllocateChunkSize' property not allowed on an underlying source for a lite ReadableStream");const r=new ReadableStream,a=new ReadableStreamDefaultController(r);return r.readableStreamController=a,a.start(t=>e.start(t)),r}ReadableStream.State={READABLE:1,CLOSED:2,ERRORED:3};class ReadableStreamDefaultReader{constructor(e){if(e.reader)throw new TypeError("ReadableStreamReader constructor can only accept readable streams that are not yet locked to a reader");this.ownerReadableStream=e,this.closedResolver=new NativeResolver,this.readRequests=[],e.state===ReadableStream.State.CLOSED?this.closedResolver.resolve():e.state===ReadableStream.State.ERRORED&&(this.closedResolver.promise.catch(()=>{}),this.closedResolver.reject(e.storedError))}get closed(){return this.closedResolver.promise}read(){if(!this.ownerReadableStream)throw new TypeError("This readable stream reader has been released and cannot be used to read from its previous owner stream");return this.readInternal()}releaseLock(){if(this.ownerReadableStream){if(this.readRequests.length)throw new TypeError("Cannot release a readable stream reader when it still has outstanding read() calls that have not yet settled");this.release()}}release(){const e=assert(this.ownerReadableStream),t=new TypeError("This readable stream reader has been released and cannot be used to monitor the stream's state");e.state===ReadableStream.State.READABLE?(this.closedResolver.promise.catch(()=>{}),this.closedResolver.reject(t)):(this.closedResolver=new NativeResolver,this.closedResolver.promise.catch(()=>{}),this.closedResolver.reject(t)),e.reader=void 0,this.ownerReadableStream=void 0}readInternal(){const e=assert(this.ownerReadableStream);return e.state===ReadableStream.State.CLOSED?Promise.resolve({value:void 0,done:!0}):e.state===ReadableStream.State.ERRORED?Promise.reject(e.storedError):e.readableStreamController.pullSteps()}}class ReadableStreamDefaultController{constructor(e){this.controlledReadableStream=e,this.queue=new Queue,this.closeRequested=!1}close(){if(!this.canCloseOrEnqueue())throw new TypeError("Cannot close a readable stream that has already been requested to be closed");this.closeInternal()}enqueue(e){if(!this.canCloseOrEnqueue())throw new TypeError("Cannot enqueue a readable stream that has already been requested to be closed");this.enqueueInternal(e)}error(e){this.errorInternal(e)}start(e){Promise.resolve(e(this)).then(()=>{this.started()},e=>{this.errorInternal(e)})}pullSteps(){if(!this.queue.empty()){const e=this.dequeueFromQueue();return this.closeRequested&&this.queue.empty()?(this.clearAlgorithms(),this.controlledReadableStream.close()):this.callPullIfNeeded(),Promise.resolve({value:e,done:!1})}const e=this.controlledReadableStream.addReadRequest();return this.callPullIfNeeded(),e}started(){}callPullIfNeeded(){}clearAlgorithms(){}closeInternal(){this.closeRequested=!0,this.queue.empty()&&(this.clearAlgorithms(),this.controlledReadableStream.close())}enqueueInternal(e){this.controlledReadableStream.locked&&this.controlledReadableStream.getNumReadRequests()>0?this.controlledReadableStream.fulfillReadRequest(e,!1):this.enqueueIntoQueue(e)}errorInternal(e){this.controlledReadableStream.state===ReadableStream.State.READABLE&&(this.resetQueue(),this.clearAlgorithms(),this.controlledReadableStream.error(e))}canCloseOrEnqueue(){return!this.closeRequested&&this.controlledReadableStream.state===ReadableStream.State.READABLE}enqueueIntoQueue(e){this.queue.enqueueValue(e)}dequeueFromQueue(){return this.queue.dequeueValue()}resetQueue(){this.queue.resetQueue()}}class Queue{constructor(){this.queue_=[]}empty(){return 0===this.queue_.length}enqueueValue(e){this.queue_.push(e)}dequeueValue(){return this.queue_.shift()}resetQueue(){this.queue_=[]}}exports={Queue:Queue,ReadableStream:ReadableStream,ReadableStreamDefaultController:ReadableStreamDefaultController,ReadableStreamDefaultReader:ReadableStreamDefaultReader,newReadableStream:newReadableStream};