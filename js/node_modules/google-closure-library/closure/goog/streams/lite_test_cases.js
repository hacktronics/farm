goog.module("goog.streams.liteTestCases"),goog.setTestOnly();const{ReadableStream:ReadableStream,ReadableStreamDefaultController:ReadableStreamDefaultController,ReadableStreamUnderlyingSource:ReadableStreamUnderlyingSource}=goog.require("goog.streams.liteTypes");goog.require("goog.testing.jsunit");class TestCases{constructor(e){this.newReadableStream=e}newReadableStreamWithController(e={}){let t;const r=e.start;e=Object.assign({},e,{start:e=>(t=e,r&&r(e))});return{stream:this.newReadableStream(e),controller:t}}async testEnqueue_ThenRead(){const{stream:e,controller:t}=this.newReadableStreamWithController();t.enqueue("foo");const r=e.getReader(),s=await r.read();assertFalse(s.done),assertEquals("foo",s.value)}testEnqueue_Closed(){const{controller:e}=this.newReadableStreamWithController();e.close(),assertThrows(()=>{e.enqueue("foo")})}testEnqueue_Closing(){const{controller:e}=this.newReadableStreamWithController();e.enqueue("foo"),e.close(),assertThrows(()=>{e.enqueue("bar")})}testEnqueue_Errored(){const{controller:e}=this.newReadableStreamWithController();e.error(new Error("error")),assertThrows(()=>{e.enqueue("foo")})}async testRead_ThenEnqueue(){const{stream:e,controller:t}=this.newReadableStreamWithController(),r=e.getReader().read();t.enqueue("foo");const s=await r;assertFalse(s.done),assertEquals("foo",s.value)}async testRead_Closed(){const{stream:e,controller:t}=this.newReadableStreamWithController();t.close();const r=e.getReader(),s=await r.read();assertTrue(s.done),assertUndefined(s.value)}async testRead_Closing(){const{stream:e,controller:t}=this.newReadableStreamWithController();t.enqueue("foo"),t.close();const r=e.getReader();let s=await r.read();assertFalse(s.done),assertEquals("foo",s.value),s=await r.read(),assertTrue(s.done),assertUndefined(s.value)}async testRead_Errored(){const{stream:e,controller:t}=this.newReadableStreamWithController(),r=new Error("error");t.error(r);const s=e.getReader(),a=await assertRejects(s.read());assertEquals(r,a)}async testRead_ThenClosed(){const{stream:e,controller:t}=this.newReadableStreamWithController(),r=e.getReader().read();t.close();const s=await r;assertTrue(s.done),assertUndefined(s.value)}async testRead_ThenErrored(){const{stream:e,controller:t}=this.newReadableStreamWithController(),r=new Error("error"),s=e.getReader().read();t.error(r);const a=await assertRejects(s);assertEquals(r,a)}testClose_Closed(){const{controller:e}=this.newReadableStreamWithController();e.close(),assertThrows(()=>{e.close()})}testClose_Closing(){const{controller:e}=this.newReadableStreamWithController();e.enqueue("foo"),e.close(),assertThrows(()=>{e.close()})}async testLocked(){const{stream:e,controller:t}=this.newReadableStreamWithController();assertFalse(e.locked);const r=e.getReader();assertTrue(e.locked),r.releaseLock(),assertFalse(e.locked)}testLocked_Closed(){const{stream:e,controller:t}=this.newReadableStreamWithController(),r=e.getReader();assertTrue(e.locked),t.close(),assertTrue(e.locked),r.releaseLock(),assertFalse(e.locked)}testLocked_Closing(){const{stream:e,controller:t}=this.newReadableStreamWithController(),r=e.getReader();t.enqueue("foo"),assertTrue(e.locked),t.close(),assertTrue(e.locked),r.releaseLock(),assertFalse(e.locked)}testLocked_Errored(){const{stream:e,controller:t}=this.newReadableStreamWithController(),r=e.getReader();assertTrue(e.locked),t.error(new Error("error")),assertTrue(e.locked),r.releaseLock(),assertFalse(e.locked)}async testClosed_Close(){const{stream:e,controller:t}=this.newReadableStreamWithController();t.close();const r=e.getReader().closed,s=await r;assertUndefined(s)}async testClosed_ThenClosed(){const{stream:e,controller:t}=this.newReadableStreamWithController(),r=e.getReader().closed;t.close();const s=await r;assertUndefined(s)}async testClosed_Closing(){const{stream:e,controller:t}=this.newReadableStreamWithController();t.enqueue("foo"),t.close();const r=e.getReader(),s=r.closed;await r.read();const a=await s;assertUndefined(a)}async testClosed_ThenClosing(){const{stream:e,controller:t}=this.newReadableStreamWithController(),r=e.getReader(),s=r.closed;t.enqueue("foo"),t.close(),await r.read();const a=await s;assertUndefined(a)}async testClosed_Errored(){const{stream:e,controller:t}=this.newReadableStreamWithController(),r=new Error("error");t.error(r);const s=e.getReader(),a=await assertRejects(s.closed);assertEquals(r,a)}async testClosed_ThenErrored(){const{stream:e,controller:t}=this.newReadableStreamWithController(),r=e.getReader().closed;t.error(new Error("error")),await assertRejects(r)}async testClosed_ThenReleaseLock(){const{stream:e}=this.newReadableStreamWithController(),t=e.getReader(),r=t.closed;t.releaseLock(),await assertRejects(r)}testGetReader_WhileLocked(){const{stream:e}=this.newReadableStreamWithController();e.getReader(),assertThrows(()=>{e.getReader()})}testReleaseLock_WhileOutstandingReads(){const{stream:e}=this.newReadableStreamWithController(),t=e.getReader();t.read(),assertThrows(()=>{t.releaseLock()})}testReleaseLock_Released(){const{stream:e}=this.newReadableStreamWithController(),t=e.getReader();t.releaseLock(),t.releaseLock()}async testStart_RejectedPromise(){const e=new Error("error"),t=this.newReadableStream({start:()=>Promise.reject(e)}).getReader(),r=await assertRejects(t.read());assertEquals(e,r)}}exports={TestCases:TestCases};